### 数据库

* 用户所有的键值对都保存在键空间的字典中,键空间的键也就是数据库的键(字符串),键空间的值对应各种不同的对象(字符串,列表,字典,集合,有序集合)

### 过期设置

* expires字典(过期字典)保存了数据库中所有键的过期时间,它的键是键空间中某个键对象的指针,值是一个毫秒unix时间戳
* 设置键的过期方法expire(几秒过期) pexpire(几毫秒过期) expireat(到unix时间过期单位秒) pexpireat(到unix时间过期单位毫秒)都是通过pexpireat作为底层实现的
* ttl(秒) pttl(毫秒)返回过期时间
* persist移除过期时间

### 过期键删除策略,实际只使用惰性删除和定期删除

* 定时删除(利用定时器删除,占用大量cpu时间),定期删除(每隔一段时间定期删除,是两者的折中),惰性删除(访问时才删除,浪费大量内存)

### 持久化

* RDB:将某一时刻的二进制数据快照持久化到磁盘中(忽略过期键)
* AOF:将指令记录下来每秒fsync到磁盘中,恢复时重新执行(主库忽略过期键,从库由于会从主库同步所以即使不忽略过期键也会被删掉,在此期间访问从库会有已过期的脏数据)
* SAVE与BGSAVE命令都是保存数据快照,但是BGSAVE是子进程执行不会阻塞服务,期间服务会拒绝BGSAVE,BGREWRITEAOF命令
* 数据恢复时AOF优先级高于RDB
* AOF可以设置刷入数据的频率,每秒刷入,一直刷入或由系统决定
* AOF重写是指遍历数据库生成新AOF文件,而无需使用老AOF文件
* 当执行BGREWRITEAOF恢复数据时,redis会维护一个AOF重写缓冲区,记录数据恢复期间新写入数据的命令,进而避免脏数据的产生,同时会使用新AOF文件替换老文件,完成重写操作

### 客户端

* 当使用AOF或者Lua脚本时客户端不使用套接字连接
* 输入缓冲区默认1G,超过则断开连接,输出缓冲区除了硬性限制外,一定时间内超过服务器的软性限制也会断开

### 服务端

* 由于获取当前时间是通过系统API消耗资源,所以服务端会储存系统时间用于对精度不高的地方(例如打印日志,更新LRU时钟),避免频繁调用,但对于设置键过期时间,添加慢查询日志等高精度功能则会再次调用系统API
